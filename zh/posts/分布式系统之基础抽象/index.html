<!doctype html><html dir=ltr lang=zh data-theme><head><title>Amao Three
|
分布式系统之基础抽象</title><meta charset=utf-8><meta name=generator content="Hugo 0.84.4"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content="
      天下有大勇者，卒然临之而不惊，无故加之而不怒；此其所挟持者甚大，而其志甚远也。--苏轼


    "><link rel=stylesheet href=/css/main.min.63415010da0fb95ab09d338a70fe53cc66ba8308019c0dcb69c3b266edfb3d70.css integrity="sha256-Y0FQENoPuVqwnTOKcP5TzGa6gwgBnA3LacOyZu37PXA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS+yuWSR4=" crossorigin=anonymous type=text/css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=/zh/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%8A%BD%E8%B1%A1/><script type=text/javascript src=/js/anatole-header.min.2a2cd9614b7d007dfbb75e8da19e3a0fa872ceab53c6d000c00b7a0c89b85bfc.js integrity="sha256-KizZYUt9AH37t16NoZ46D6hyzqtTxtAAwAt6DIm4W/w=" crossorigin=anonymous></script><script type=text/javascript src=/js/anatole-theme-switcher.min.7fd87181cdd7e8413aa64b6867bb32f3a8dc242e684fc7d5bbb9f600dbc2b6eb.js integrity="sha256-f9hxgc3X6EE6pktoZ7sy86jcJC5oT8fVu7n2ANvCtus=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="分布式系统之基础抽象"><meta name=twitter:description content="1. 分布式抽象的必要性 1.1 任何分布式系统的核心都是分布式算法 作为网络（系统）与应用的中间件实现。
   系统的通道 <&mdash;&mdash;-> 系统的通道     中间件的算法  中间件的算法   应用  应用    1.2 可靠的应用需要比网络协议（e.g. TCP，UDP）更强大的底层服务 1.2.1 通信  只能为一对一通信（客户端-服务端）提供可靠性保证（比如TCP） 如何做到组通信？   可靠广播 Reliable Broadcast
因果顺序广播 Causal order Broadcast
全序广播 Total order Broadcast
 1.2.2 高层服务  有时，多对多通讯是不够的 需要可靠的高层服务   共享内存
共识（Consensus, 不是Consistency）
原子性提交
复制状态机
 1.3 举例 ①. 可靠广播 确保发送至组的信息要么被所有成员收到要么没有一个成员收到
②. 原子性提交 确保各进程就是否提交或终止事务（Transaction）达成一致决定。（既确保状态一致）
2. 基于事件的组件模型 2."></head><body><header><div class="page-top
animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a><nav><ul class=nav__list id=navMenu><div class=nav__links><li><a href=/zh/ title>主页</a></li><li><a href=/zh/posts/ title>文章</a></li><li><a href=/zh/about/ title>关于我</a></li><li><a href=/zh/ title=中文>中文</a></li><li><a href=/en/ title=EN>EN</a></li></div><li><a class=theme-switch title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></li></ul></nav></div></header><div class=wrapper><aside><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=logo-title><div class=title><img src=/images/profile.jpg alt="profile picture"><h3 title><a href=/>阿毛的随便写写</a></h3><div class=description><p>天下有大勇者，卒然临之而不惊，无故加之而不怒；此其所挟持者甚大，而其志甚远也。--苏轼</p></div></div></div><ul class=social-links><li><a href=https://www.linkedin.com/in/yuehao-sui/ rel=me aria-label=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li><a href=https://github.com/amaothree rel=me aria-label=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li><a href=https://www.instagram.com/yoohoo.samuel/ rel=me aria-label=instagram><i class="fab fa-instagram fa-2x" aria-hidden=true></i></a></li><li><a href=mailto:ihidemyname@outlook.com rel=me aria-label=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer--sidebar"><div class=by_farbox><ul class=footer__list><li class=footer__item>&copy;
2019-2021</li></ul></div></footer><script type=text/javascript src=/js/medium-zoom.min.71100d84fab0ad794b8399a66ac810700cc78d703f715dc10af4d7ba7b761362.js integrity="sha256-cRANhPqwrXlLg5mmasgQcAzHjXA/cV3BCvTXunt2E2I=" crossorigin=anonymous></script></div></aside><main><div class=autopagerize_page_element><div class=content><div class="post
animated fadeInDown"><div class=post-content><div class=post-title><h1>分布式系统之基础抽象</h1><div class=info><em class="fas fa-calendar-day"></em><span class=date>Tue, Mar 16, 2021</span>
<em class="fas fa-stopwatch"></em><span class=reading-time></span></div></div><h2 id=1-分布式抽象的必要性>1. 分布式抽象的必要性</h2><h3 id=11-任何分布式系统的核心都是分布式算法>1.1 任何分布式系统的核心都是分布式算法</h3><p>作为网络（系统）与应用的中间件实现。</p><table><thead><tr><th style=text-align:center>系统的通道</th><th>&lt;&mdash;&mdash;-></th><th style=text-align:center>系统的通道</th></tr></thead><tbody><tr><td style=text-align:center>中间件的算法</td><td></td><td style=text-align:center>中间件的算法</td></tr><tr><td style=text-align:center>应用</td><td></td><td style=text-align:center>应用</td></tr></tbody></table><h3 id=12-可靠的应用需要比网络协议eg-tcpudp更强大的底层服务>1.2 可靠的应用需要比网络协议（e.g. TCP，UDP）更强大的底层服务</h3><h4 id=121-通信>1.2.1 通信</h4><ul><li>只能为一对一通信（客户端-服务端）提供可靠性保证（比如TCP）</li><li>如何做到组通信？</li></ul><blockquote><p>可靠广播 Reliable Broadcast<br>因果顺序广播 Causal order Broadcast<br>全序广播 Total order Broadcast</p></blockquote><h4 id=122-高层服务>1.2.2 高层服务</h4><ul><li>有时，多对多通讯是不够的</li><li>需要可靠的高层服务</li></ul><blockquote><p>共享内存<br>共识（Consensus, 不是Consistency）<br>原子性提交<br>复制状态机</p></blockquote><h3 id=13-举例>1.3 举例</h3><h4 id=-可靠广播>①. 可靠广播</h4><p>确保发送至组的信息要么被<strong>所有成员</strong>收到要么<strong>没有一个成员</strong>收到</p><h4 id=-原子性提交>②. 原子性提交</h4><p>确保各进程就是否提交或终止事务（Transaction）达成一致决定。（既确保状态一致）</p><h2 id=2-基于事件的组件模型>2. 基于事件的组件模型</h2><h3 id=21-分布式计算模型>2.1 分布式计算模型</h3><ul><li>一组进程与一个网络（通讯连接）</li><li>单一进程执行单一本地算法（程序）</li><li>每个进程都会进行计算步骤</li><li>网络进行计算步骤:<ul><li>存储进程发送的消息</li><li>传递消息给某一进程</li></ul></li><li>消息传递时会在接收过程中触发一个计算步骤</li></ul><h4 id=211-一个进程的计算步骤>2.1.1 一个进程的计算步骤</h4><ol><li>接收一个消息（外部，输入）</li><li>执行本地计算</li><li>发送一个或多个消息给其他一些进程（外部，输出）</li></ol><h4 id=212-通信步骤>2.1.2 通信步骤</h4><ol><li>基于网络抽象</li><li>收到来自一个进程的消息，或者</li><li>发送一个消息给一个进程</li></ol><h3 id=22-进程内部>2.2 进程内部</h3><ul><li>一个进程包括一组组件（自动机）</li><li>组件都是并行的</li><li>每个组件通过一个FIFO输入缓冲接收消息</li><li>发送消息给其他组件</li><li>事件是同一进程内不同组件间的消息</li><li>事件被称为事件处理者（Event Handler）的程序（行动）处理</li></ul><h3 id=23-基于事件编程>2.3 基于事件编程</h3><h4 id=231-进程执行程序>2.3.1 进程执行程序</h4><ul><li>每个程序包含了一组模块与组件规范</li><li>在运行时，这些被部署为组件</li><li>一般来说，这些组件组成了一个软件栈</li><li>组件通过事件进行交互（伴随属性）：</li><li>被事件处理者处理</li></ul><pre><code class=language-pseudocode data-lang=pseudocode>on event&lt;COi Event1, attr1, attr2,...&gt; do
  // local computation
  trigger&lt;COj Event2, attr3, attr4,...&gt;
</code></pre><h4 id=232-几乎任何东西都可以是事件>2.3.2 几乎任何东西都可以是事件</h4><ul><li>消息（大多数时候）</li><li>计时器（内部事件）</li><li>条件（e.g. x==5 & y&lt;9）</li></ul><h4 id=233-两种事件类型>2.3.3 两种事件类型</h4><ul><li>请求(Requests)</li></ul><blockquote><p>（向下流动）输入</p></blockquote><ul><li>指示(Indications)</li></ul><blockquote><p>（如回复/确认 向上流动）输出</p></blockquote><h3 id=24-进程中的组件>2.4 进程中的组件</h3><p>单一过程中的组件堆栈</p><p><img src=/images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%A1%80/1.png alt=单一过程中的组件堆栈></p><h3 id=25-通道即是模块>2.5 通道即是模块</h3><p>通道也用模块来体现。</p><ul><li>请求事件: 发送一些（带数据的）消息给目的地</li></ul><blockquote><p><code>trigger&lt;send|dest,[data1,data2,...]></code></p></blockquote><ul><li>指示事件：从源获取一些（带数据的）消息</li></ul><blockquote><p><code>upon event&lt;deliver|src,[data1,data2,...]></code></p></blockquote><h4 id=26-举例>2.6 举例</h4><p>使用一个广播组件的应用，使用通道组件进行广播</p><p><img src=/images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%A1%80/2.png alt=举例></p><h2 id=3-规格>3. 规格</h2></div><div class=post-footer><div class=info></div></div><div id=fb_comments_container><h2></h2><script src=https://utteranc.es/client.js repo=amaothree/gitalk-repo issue-term=title theme=github-dark-orange crossorigin=anonymous async></script></div></div></div></div></main></div><footer class="footer footer--base"><div class=by_farbox><ul class=footer__list><li class=footer__item>&copy;
2019-2021</li></ul></div></footer><script type=text/javascript src=/js/medium-zoom.min.71100d84fab0ad794b8399a66ac810700cc78d703f715dc10af4d7ba7b761362.js integrity="sha256-cRANhPqwrXlLg5mmasgQcAzHjXA/cV3BCvTXunt2E2I=" crossorigin=anonymous></script></body></html>